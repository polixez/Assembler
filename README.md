# Ассемблер и Интерпретатор Учебной Виртуальной Машины (УВМ)

---

## 1. Общее описание

Данный проект реализует ассемблер и интерпретатор для учебной виртуальной машины (УВМ) на языке Python. Ассемблер переводит исходный код программы, написанный на ассемблере УВМ, в бинарный файл, понятный виртуальной машине, а также создает лог-файл в формате XML с информацией об ассемблированных инструкциях. Интерпретатор выполняет бинарный файл, интерпретируя инструкции УВМ, и сохраняет результаты выполнения в файл-результат в формате XML, отображающий значения в памяти УВМ после выполнения программы.

Проект включает автоматический скрипт сборки, который последовательно запускает ассемблер и интерпретатор, упрощая процесс разработки и тестирования программ для УВМ.

---

## 2. Функции и настройки
### Основные компоненты

1. **Ассемблер (```assembler.py```)**

- Цель: Переводит исходный код программы на языке ассемблера УВМ в бинарный файл (```binary.bin```) и создает лог-файл (```log.xml```) с информацией об инструкциях.
- Функции:

    - ```assemble_instruction(line)```: Парсит строку исходного кода и преобразует её в бинарную инструкцию.
    - ```assemble(source_file, binary_file, log_file)```: Обрабатывает весь исходный файл, генерирует бинарный файл и лог-файл.
- Настройки:
    - Аргументы командной строки:
        - ```<source_file>```: Путь к исходному файлу программы (например, test_files/test_source.asm).
        - ```<binary_file>```: Путь для сохранения бинарного файла (например, test_files/binary.bin).
        - ```<log_file>```: Путь для сохранения лог-файла (например, test_files/log.xml).

2. **Интерпретатор (```interpreter.py```)**

- Цель: Выполняет бинарный файл программы УВМ и создает файл-результат (```result.xml```) с дампом памяти после выполнения.
- Функции:
    - ```interpret(binary_file, memory_dump_file, mem_start, mem_end```): Выполняет инструкции из бинарного файла и сохраняет результат в указанный диапазон памяти.
- Настройки:
    - Аргументы командной строки:
        - ```<binary_file>```: Путь к бинарному файлу программы (например, test_files/binary.bin).
        - ```<memory_dump_file>```: Путь для сохранения файла-результата (например, test_files/result.xml).
        - ```<mem_start>```: Начальный адрес памяти для дампа.
        - ```<mem_end>```: Конечный адрес памяти для дампа.

3. **Файл-скрипт для автоматической сборки (```build.py```)**

- Цель: Автоматизирует процесс сборки и выполнения программы, последовательно запускает ассемблер и интерпретатор. Тестирование ассемблера и интерпретатора.
- Функции:
    - ```assemble_program()```: Запуск ассемблера
    - ```run_interpreter()```: Запуск интерпретатора
    - ```run_tests()```: Производит инициализацию тестов
    - ```main()```: Определяет пути к файлам, формирует команды для ассемблера и интерпретатора, выполняет их, запускает тесты, обрабатывает результаты.
- Настройки:
    - Пути к файлам задаются внутри скрипта и могут быть изменены при необходимости.


### Поддерживаемые команды УВМ

1. **LDC (Load Constant)**

    Описание: Загружает константу в аккумулятор.
    
    Формат: ```LDC <константа>```

    Пример: ```LDC 10```
2. **LD (Load)**

    Описание: Читает значение из памяти по адресу аккумулятор + смещение и загружает его в аккумулятор.

    Формат: ```LD <смещение>```

    Пример: ```LD 5```

3. **ST (Store)**

    Описание: Сохраняет значение аккумулятора в память по указанному адресу.

    Формат: ```ST <адрес>```

    Пример: ```ST 15```

4. **EQ (Equal)**

    Описание: Сравнивает аккумулятор с значением из памяти по адресу, сохраняет результат (1 или 0) в аккумулятор.

    Формат: ```EQ <адрес>```

    Пример: ```EQ 20```

---
## 3. Команды для сборки проекта
Для автоматической сборки проекта используется скрипт ```build.py```, который последовательно запускает ассемблер и интерпретатор.

### Сборка и запуск тестов:
**Запуск сборки через ```build.py```:**

```python
import os
import sys
import subprocess
import unittest


def assemble_program():
    print("Запуск ассемблера...")
    assemble_script = os.path.abspath(os.path.join(os.path.dirname(__file__), 'assembler.py'))
    source_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_files', 'test_source.asm'))
    binary_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_files', 'binary.bin'))
    log_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_files', 'log.xml'))

    result = subprocess.run([sys.executable, assemble_script, source_file, binary_file, log_file],
                            capture_output=True, text=True)
    if result.returncode != 0:
        print("Ошибка при сборке ассемблера:")
        print(result.stderr)
        sys.exit(1)
    else:
        print("Ассемблер успешно выполнен.")


def run_interpreter():
    print("Запуск интерпретатора...")
    interpreter_script = os.path.abspath(os.path.join(os.path.dirname(__file__), 'interpreter.py'))
    binary_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_files', 'binary.bin'))
    memory_dump_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'test_files', 'result.xml'))
    mem_start = '0'
    mem_end = '7'

    result = subprocess.run([sys.executable, interpreter_script, binary_file, memory_dump_file, mem_start, mem_end],
                            capture_output=True, text=True)
    if result.returncode != 0:
        print("Ошибка при выполнении интерпретатора:")
        print(result.stderr)
        sys.exit(1)
    else:
        print("Интерпретатор успешно выполнен.")


def run_tests():
    print("Запуск тестов...")
    tests_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'tests'))
    loader = unittest.TestLoader()
    suite = loader.discover(tests_dir)
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    if not result.wasSuccessful():
        print("Тесты завершились с ошибками.")
        sys.exit(1)
    else:
        print("Все тесты прошли успешно.")


def main():
    assemble_program()
    run_interpreter()
    run_tests()
    print("Сборка, выполнение и тестирование завершены успешно.")


if __name__ == "__main__":
    main()
```

Скрипт выполняет следующие действия:

1. **Запуск ассемблера:**

- Ассемблирует исходный код из ```test_files/test_source.asm``` в бинарный файл ```test_files/binary.bin.```
- Создает лог-файл ```test_files/log.xml``` с информацией об инструкциях.
- Пример ```log.xml`` файла:

  ![image](https://github.com/user-attachments/assets/e831a09b-b455-4cc5-ae9e-35ec4ff1077e)

2. **Запуск интерпретатора:**

- Выполняет инструкции из ```test_files/binary.bin.```
- Создает файл-результат ```test_files/result.xml``` с дампом памяти по адресам 0–7.


2. **Запуск тестов:**

- Производит запуск тестов ```test_assembler_case_1```, ```test_assembler_case_2```, ```test_assembler_case_3``` для ассемблера программы.
- Производит запуск тестов ```test_interpreter_case_1```, ```test_interpreter_case_2```, ```test_interpreter_case_1``` для интерпретатора.
---

## 4. Примеры использования

### Запуск Автоматической Сборки
**Команда:**

```powershell
python build.py
```

**Описание:**

При запуске скрипта ```build.py``` происходит автоматическая ассемблировка и выполнение программы. В терминале отображаются сообщения о запуске и успешном выполнении ассемблера и интерпретатора, а также вывод результатов тестов.

### Результаты Выполнения Ассемблированной Программы
**Команда:**

```powershell
python interpreter.py test_files/binary.bin test_files/result.xml 0 7
```

![Снимок экрана 2024-11-27 064800](https://github.com/user-attachments/assets/7c159b24-9f3d-4889-8c75-f2273d0d96f9)

**Описание:**

После выполнения интерпретатора создается файл result.xml, который содержит дамп памяти. В этом примере показаны значения векторов A и B после выполнения программы, где векторы B обновлены результатами сравнения.

### Проверка Бинарного Файла в HxD

**Действия:**

1. Откройте binary.bin в HxD.
2. Проверьте, что каждая инструкция занимает 4 байта и соответствует ожиданиям.

![Снимок экрана 2024-11-27 064819](https://github.com/user-attachments/assets/f21542f0-22ff-46e0-8352-bff86061fa74)

**Описание:**

В HxD можно убедиться, что бинарный файл ```binary.bin``` содержит правильные инструкции в формате little-endian, соответствующие лог-файлу ```log.xml```.


---

## 5. Результаты прогона тестов

### Запуск тестов
Для проверки корректности работы всех функций и компонентов проекта используется автоматический файл-скрипт ```build.py```. В данном скрипте также содержится фунция запуска трёх тестов ```test_case_1.asm```, ```test_case_1.asm```, ```test_case_1.asm```. Данные тесты проверяют работу программы с различными элементами и операндами.

**Структура ```test_case_1.asm``` - Простое сравнение равных элементов:**

![image](https://github.com/user-attachments/assets/9df7febe-a8d8-4292-96c7-61bf25f02889)

**Структура ```test_case_2.asm``` - Сравнение неравных элементов:**

![image](https://github.com/user-attachments/assets/03f5a1c6-98d5-4692-aef6-146bc152919c)

**Структура ```test_case_3.asm``` - Сравнение с различными операндами:**

![image](https://github.com/user-attachments/assets/65a8df40-b33f-4238-8bbb-8aa7af883e69)

Далее используя данные из этих тестовых файлов мы запускаем тесты для интерпретатора с помощью функции ```test_interpreter```, и для ассемблера с помощю функции ```test_assembler```.

**Команда для запуска тестов через автоматический скрипт:**

```bash
python build.py
```

**Результаты выполнения тестов:**

![image](https://github.com/user-attachments/assets/c98ca55a-3405-4aef-9078-b91bf5fd8cbb)


**Все тесты прошли успешно, подтверждая полное соответствие функционала требованиям задания.**
